---
twocol: FALSE  #  Use FALSE for submission. 
title: Title here
author1: 
  name: Elio Campitelli
  email: elio.campitelli@cima.fcen.uba.ar
author2: 
  name: Leandro DÃ­az
affiliation: "CIMA UBA blablabla"
extra_authors: 
  - name: Carolina Vera
abstract: |
  Enter the text of your abstract here. This is a sample American Meteorological Society (AMS) \LaTeX\ template.  This document provides authors with instructions on the use of the AMS \LaTeX\ template.  Authors should refer to the file amspaper.tex to review the actual \LaTeX\ code used to create this document. The template.tex file should be modified by authors for their own manuscript.
statement: |
  This is significant becasue I wrote it.
bibliography: AsymSAM.bib
output: 
  rticles::ams_article:
    latex_engine: "xelatex"
header-includes: 
 - \usepackage{gensymb}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.path = "",     # AMS required
                      out.extra = "",    # To force figure labels
                      echo = FALSE)      # Don't show R code   


# This helps to use appendix figures.
appendcaption <- function (x, options) {
  `%n%` <- knitr:::`%n%`
  rw = options$resize.width
  rh = options$resize.height
  resize1 = resize2 = ""
  if (!is.null(rw) || !is.null(rh)) {
    resize1 = sprintf("\\resizebox{%s}{%s}{", rw %n% "!", 
                      rh %n% "!")
    resize2 = "} "
  }
  tikz = knitr:::is_tikz_dev(options)
  a = options$fig.align
  fig.cur = options$fig.cur %n% 1L
  fig.num = options$fig.num %n% 1L
  animate = options$fig.show == "animate"
  fig.ncol = options$fig.ncol %n% fig.num
  if (is.null(fig.sep <- options$fig.sep)) {
    fig.sep = character(fig.num)
    if (fig.ncol < fig.num) 
      fig.sep[seq(fig.ncol, fig.num - 1L, fig.ncol)] = "\\newline"
  }
  sep.cur = NULL
  if (!tikz && animate && fig.cur < fig.num) 
    return("")
  usesub = length(subcap <- options$fig.subcap) && fig.num > 
    1
  ai = options$fig.show != "hold"
  plot1 = ai || fig.cur <= 1L
  plot2 = ai || fig.cur == fig.num
  align1 = if (plot1) 
    switch(a, left = "\n\n", center = "\n\n{\\centering ", 
           right = "\n\n\\hfill{}", "\n")
  align2 = if (plot2) 
    switch(a, left = "\\hfill{}\n\n", center = "\n\n}\n\n", 
           right = "\n\n", "")
  cap = options$fig.cap
  appendix = !is.null(options$appendix)
  scap = options$fig.scap
  fig1 = fig2 = ""
  mcap = fig.num > 1L && options$fig.show == "asis" && !length(subcap)
  sub1 = sub2 = ""
  if (length(cap) && !is.na(cap)) {
    lab = paste0(options$fig.lp, options$label)
    if (plot1) {
      pos = options$fig.pos
      if (pos != "" && !grepl("^[[{]", pos)) 
        pos = sprintf("[%s]", pos)
      fig1 = sprintf("\\begin{%s}%s", options$fig.env, 
                     pos)
    }
    if (usesub) {
      sub1 = sprintf("\\subfloat[%s%s]{", subcap, knitr:::create_label(lab, 
                                                               fig.cur, latex = TRUE))
      sub2 = "}"
      sep.cur = fig.sep[fig.cur]
      if (is.na(sep.cur)) 
        sep.cur = NULL
    }
    if (plot2) {
      if (is.null(scap) && !grepl("[{].*?[:.;].*?[}]", 
                                  cap)) {
        scap = strsplit(cap, "[:.;]( |\\\\|$)")[[1L]][1L]
      }
      scap = if (is.null(scap) || is.na(scap)) 
        ""
      else sprintf("[%s]", scap)
      if (cap == "") {
        cap = ""
      } else if (appendix == TRUE) {
        cap = sprintf("\\appendcaption{%s}{%s}%s\n", options$label, cap, knitr:::create_label(lab, 
                                                                  if (mcap) 
                                                                    fig.cur, latex = TRUE))
      } else {
        cap = sprintf("\\caption%s{%s}%s\n", scap, cap, knitr:::create_label(lab, 
                                                                  if (mcap) 
                                                                    fig.cur, latex = TRUE))
      }
      fig2 = sprintf("%s\\end{%s}\n", cap, options$fig.env)
    }
  }
  else if (knitr:::pandoc_to(c("latex", "beamer"))) {
    align.env = switch(a, left = "flushleft", center = "center", 
                       right = "flushright")
    align1 = if (plot1) 
      if (a == "default") 
        "\n"
    else sprintf("\n\n\\begin{%s}", align.env)
    align2 = if (plot2) 
      if (a == "default") 
        ""
    else sprintf("\\end{%s}\n\n", align.env)
  }
  ow = options$out.width
  if (animate && identical(ow, "\\maxwidth")) 
    ow = NULL
  if (is.numeric(ow)) 
    ow = paste0(ow, "px")
  size = paste(c(sprintf("width=%s", ow), sprintf("height=%s", 
                                                  options$out.height), options$out.extra), collapse = ",")
  paste0(fig1, align1, sub1, resize1, if (tikz) {
    sprintf("\\input{%s}", x)
  }
  else if (animate) {
    aniopts = options$aniopts
    aniopts = if (is.na(aniopts)) 
      NULL
    else gsub(";", ",", aniopts)
    size = paste(c(size, sprintf("%s", aniopts)), collapse = ",")
    if (nzchar(size)) 
      size = sprintf("[%s]", size)
    sprintf("\\animategraphics%s{%s}{%s}{%s}{%s}", size, 
            1/options$interval, sub(sprintf("%d$", fig.num), 
                                    "", xfun::sans_ext(x)), 1L, fig.num)
  }
  else {
    if (nzchar(size)) 
      size = sprintf("[%s]", size)
    res = sprintf("\\includegraphics%s{%s} ", size, if (getOption("knitr.include_graphics.ext", 
                                                                  FALSE)) 
      x
      else xfun::sans_ext(x))
    lnk = options$fig.link
    if (is.null(lnk) || is.na(lnk)) 
      res
    else sprintf("\\href{%s}{%s}", lnk, res)
  }, resize2, sub2, sep.cur, align2, fig2)
}


knitr::knit_hooks$set(plot = appendcaption)
```

```{r, warning=FALSE, message = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  cache = TRUE,
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  comment = "#>",
  cache.path = "../cache/",
  cache.extra = 3,
  dpi = 300
)

library(metR)
library(data.table)
library(ggplot2)
library(magrittr)
library(ggperiodic)
library(asymsam)
library(latex2exp)

theme_set(theme_asymsam(base_size = 10))
ZeroBreaks <- AnchorBreaks(0, NULL, 0)
axis_labs_smol <- theme(axis.text = element_text(size = 6))
lev.lab <- AddSuffix(" hPa")

guide_colorstrip_bottom <- function(width = 25, height = 0.5, ...) {
  guide_colorstrip(title.position = "top", title.hjust = 0.5,
                   barheight = height,
                   barwidth = width, ...)
}

knitr::opts_hooks$set(invisible = function(options) {
  options$include = FALSE
  options
})

main_levs <- c(700, 300, 30)
```


<!-- The actual document text starts here: -->

# Introduction 

yada yada SAM yada yada circulation.. yada yada so important. yada yada many impacts. 


```{r read-hgt}
hgt <- ReadNetCDF(ERA5(), 
                  subset = list(time = c("1979-01-01", "2018-12-31"),
                                latitude = c(-90, 10),
                                level = as.list(main_levs)),
                  vars = c(hgt = "z")) %>% 
  normalise_coords() %>% 
  .[, hgt := hgt/9.8] %>% 
  .[, hgt_a := hgt - mean(hgt), by = .(lon, lat, lev, month(time))]
```

```{r compute-SAM}
SAM <- hgt[lat <= -20] %>% 
  .[, hgt := hgt_a*sqrt(cos(lat*pi/180))] %>% 
  .[, .(eof = list(eof_flip(EOF(hgt ~ time | lon + lat, n = 1, data = .SD)))), 
    by = .(lev)]

dims <- hgt[lat <= -20] %>% 
  .[, .(x = uniqueN(lon), y = uniqueN(lat), t = uniqueN(time))]
```


# Methods

### Data 

We used monthly geopotential height at 2.5 longitude by 2.5 latitude resolution from ERA5 [@hersbach] for the period 1979 to 2018 (inclusive).

Monthly temperature NOAA Global Surface Temperature (NOAAGlobalTemp) 5.0 degree latitude x 5.0 degree longitude global grid [@vose2012; @smith2008]. The same analysis was carried out using CRUTEM4 [@osborn2014] (not shown). 

We used monthly precipitation data from CPC Merged Analysis of Precipitation [@xie1997] 2.5 degree latitude x 2.5 degree longitude.  


### Definition of indexes

We defined the Southern Annular Mode (SAM) as the leading EOF of the monthly anomalies of geopotential field at 700 hPa south of 20\degree S (citation?). The EOF was performed by computing the Singular Value Decomposition of the data matrix consisting in `r dims$t` rows and  `r dims$x*dims$y` columns (`r dims$x` points of longitude and `r dims$y` points of latitude). The values where weighted by the square root of the cosine of latitude to account for the non-equal area of each gridpoint [@chung1999]. This same method was used at the rest of the levels considered in this paper. 

To separate between the zonally symmetric and asymmetric components of the SAM, we computed the zonal mean and anomalies of the full SAM spatial pattern. The results are shown in Figure\ \ref{fig:method} for 700hPa. The full spatial signal ($\mathrm{EOF_1}(\lambda, \phi)$) is the sum of the zonally asymmetric ($\mathrm{EOF_1^*}(\lambda, \phi)$) and symmetric ($[\mathrm{EOF_1}](\lambda, \phi)$) components. We then compute the "Full", "Asymmetric" and "Symmetric" indexes, by regressing each geopotential field on these patterns (weighting by the cosine of latitude).

The three indexes are normalised by dividing them by the standard deviation of the "Full" index at each level. This means that comparing the magnitude between indexes is meaningful, but it also means that not every index will have unit standard deviation. 

```{r method, fig.cap = "Spatial patterns of the first EOF of 700 hPa geopotential height. Full field (left), zonally asymmetric component (middle) and zonally symmetric component (right). Arbitrary units.", fig.width=6, fig.height=3, fig.env="figure*"}
sam_sep <- SAM[, eof[[1]]$right, by = .(lev)] %>% 
  setnames("hgt", "full") %>% 
  .[, c("sym", "asym") := list(mean(full), Anomaly(full)), by = .(lat, lev)]


lab_sam <-  c(full = "Full", 
              asym = "Asymmetric",
              sym  = "Symmetric")

lab_eof <- c(full = TeX("$\\mathrm{EOF_1}(\\lambda, \\phi)$"),
             asym = TeX("$\\mathrm{EOF_1}^*(\\lambda, \\phi)$"), 
             sym  = TeX("$\\[\\mathrm{EOF_1}\\](\\lambda, \\phi)$"))

sam_sep %>% 
  .[lev == 700] %>%
  rm_singleton() %>% 
  melt(id.vars = c("lon", "lat")) %>% 
  .[variable == "sym", value := value + rnorm(.N, 0, sd = 1e-6)] %>%
  .[, variable := factor(variable, levels = names(lab_sam), ordered = TRUE)] -> sam_plot


levels(sam_plot$variable) <- lab_eof

sam_plot %>% 
  periodic(lon = c(0, 360)) %>%
  ggplot(aes(lon, lat)) +
  # geom_contour(aes(z = value, linetype = factor(-sign(..level..))), global.breaks = FALSE) +
  geom_contour_fill(aes(z = value), global.breaks = FALSE, breaks = ZeroBreaks) +
  geom_contour_tanaka(aes(z = value), global.breaks = FALSE, breaks = ZeroBreaks) +
  geom_qmap() +
  scale_x_longitude() +
  scale_y_latitude(limits = c(NA, -20), labels = NULL) +
  scale_fill_divergent(guide = "none") +
  coord_polar() +
  facet_grid(~variable, labeller = labeller(variable = label_parsed, lev = lev.lab)) +
  axis_labs_smol
```


### Significance

We adjusted p-values for False Detection Rate following @wilks2016. 


# Results

```{r compute-asymsam}
indexes_file <- data_path("derived", "indexes.Rds")
if (file.exists(indexes_file)) {
  indexes <- readRDS(indexes_file)
} else {
  stop("Run 02-compute-eofs.R")
}

indexes_wide <- dcast(indexes, + lev + time ~ term, value.var = "estimate_norm")
```



```{r asymsam-timeseries, fig.cap = "Time series for the asymmetric SAM and symmetric SAM.", fig.width=6, fig.height=3, fig.env="figure*"}
indexes %>% 
  .[lev %in% c(30, 700) & term != "full"] %>% 
  # .[, estimate_norm := estimate_norm/sd(estimate_norm), by = .(lev, term)] %>% 
  ggplot(aes(time, estimate_norm)) +
  geom_line(aes(color = term)) +
  scale_color_brewer(NULL, palette = "Set1", labels = lab_sam) +
  scale_y_continuous(NULL) +
  scale_x_datetime(NULL) +
  facet_grid(lev~., labeller = labeller(lev = lev.lab), scales = "free")
```


```{r cor-lev, fig.cap = "Correlation between the Symmetric and Asymmetric SAM at each level.", fig.width=3, fig.height=3.5}
indexes_wide[, cor(asym, sym), by = lev] %>% 
  ggplot(aes(lev, V1)) +
  geom_line() +
  scale_x_level() + 
  scale_y_continuous("Correlation", limits = c(0, 1)) + 
  coord_flip()
```

```{r cross-correlation, fig.cap = "Cross correlation between levels of the Full, Asymmetric and Symmetric SAM.", fig.width = 6, fig.height=4, fig.env="figure*"}
tri <- matrix(c(1000, 1000, 1000, 1, 1, 1, 1000, 1000), ncol = 2, byrow = TRUE) %>% 
  as.data.table() %>% 
  setnames(., colnames(.), c("item1", "item2"))

logbreaks <- function(range) {
  ticks <- ggplot2:::calc_logticks(minpow = log10(min(range)), maxpow = log10(max(range)))
  ticks$value[ticks$end == 0.2]
}

indexes %>% 
  copy() %>% 
  .[, widyr::pairwise_cor(.SD, lev, time, estimate, diag = FALSE), by = .(term)] %>% 
  ggplot(aes(item2, item1)) +
  geom_contour_fill(aes(z = correlation), na.fill = .99, breaks = MakeBreaks(binwidth = 0.1)) +
  geom_polygon(data = tri, fill = "white") +
  scale_fill_divergent("Cross-correlation", 
                       breaks = MakeBreaks(binwidth = 0.1),
                       guide = guide_colorstrip_bottom()) +
  scale_x_level(minor_breaks = logbreaks, position = "top") +
  scale_y_level(minor_breaks = logbreaks) +
  coord_equal() +
  facet_grid(. ~ term, labeller = labeller(term = lab_sam)) +
  theme(panel.spacing.x = unit(2, "lines"), strip.placement = "outside")
```

```{r compute-regr-pattern}
indexes_2d_yearly <- hgt[lev %in% main_levs] %>% 
  indexes_wide[., on = .NATURAL, allow.cartesian = TRUE] %>% 
  .[, rbind(as.data.table(FitLm(hgt_a, sym, asym)),
            as.data.table(FitLm(hgt_a, full))),
    by = .(lon, lat, lev)] %>% 
  rm_intercept() %>% 
  periodic(lon = c(0, 360)) %>% 
  .[, term := factor(term, levels = names(lab_sam), ordered = TRUE)] 
```


```{r 2d-regr, fig.cap = "Regression patterns of geopotential height at 30, 300 and 700 hPa with the Full, Asymmetric and Symmetric SAM. The regression patterns for Asymmetric and Symmetric SAM are the result of one multiple regression using both indices, not of two simple regressions involving each index by itsef.", fig.env = "figure*", fig.width=6, fig.height=7}
indexes_2d_yearly %>% 
  .[lat <= -20] %>% 
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = estimate), breaks = ZeroBreaks, global.breaks = FALSE) +
  # geom_contour2(aes(z = estimate, linetype = factor(-sign(..level..))), 
  # size = 0.3,
  # global.breaks = FALSE) +
  geom_contour_tanaka(aes(z = estimate),
                      breaks = ZeroBreaks,
                      size = 0.3,
                      global.breaks = FALSE) +
  geom_qmap(~.x[lat <= -20]) +
  # geom_contour2(data = ~.x[dataset == "NCEP"], aes(z = V1)) +
  scale_x_longitude() +
  scale_y_latitude(limits = c(NA, -20), labels = NULL) +
  scale_fill_divergent(NULL, guide = guide_colorstrip_bottom(), 
                       limits = c(-85, 85),
                       oob = scales::squish,
                       breaks = MakeBreaks(binwidth = 20, exclude = 0)) +
  scale_linetype(guide = "none") +
  coord_polar() +
  facet_grid(term ~ lev, labeller = labeller(term = lab_sam, lev = lev.lab)) +
  axis_labs_smol 
```
`r paste(stringi::stri_rand_lipsum(2, FALSE), collapse = "\n\n")`

```{r compute-regr-pattern-season}
indexes_2d <- hgt[lev %in% main_levs] %>% 
  indexes_wide[., on = .NATURAL, allow.cartesian = TRUE] %>% 
  .[, rbind(as.data.table(FitLm(hgt_a, sym, asym)),
            as.data.table(FitLm(hgt_a, full))),
    by = .(lon, lat, lev, season(time))] %>% 
  rm_intercept() %>% 
  periodic(lon = c(0, 360)) %>% 
  .[, term := factor(term, levels = names(lab_sam), ordered = TRUE)] 
```

```{r 2d-regr-700, fig.cap = "Seasonal regression patterns of geopotential height at 700 hPa with the Full, Asymmetric and Symmetric SAM. The regression patterns for Asymmetric and Symmetric SAM are the result of one multiple regression using both indices, not of two simple regressions involving each index by itsef.", fig.width =10, fig.height=7, fig.env = "sidewaysfigure"}
indexes_2d %>% 
  .[lat <= -20] %>% 
  .[lev == 700] %>% 
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = estimate),  breaks = AnchorBreaks(0, binwidth = 5, 0),
                    global.breaks = FALSE) +
  geom_contour_tanaka(aes(z = estimate),
                      breaks = AnchorBreaks(0, binwidth = 5, 0),
                      size = 0.3,
                      global.breaks = FALSE) +
  geom_qmap(~.x[lat <= -20]) +
  scale_x_longitude() +
  scale_y_latitude(limits = c(NA, -20), labels = NULL) +
  scale_fill_divergent(NULL, guide = guide_colorstrip_bottom(),
                       limits = c(-55, 55),
                       oob = scales::squish,
                       breaks = AnchorBreaks(0, binwidth = 5, 0)) +
  scale_linetype(guide = "none") +
  coord_polar() +
  facet_grid(term ~ season, labeller = labeller(term = lab_sam, lev = lev.lab)) +
  axis_labs_smol
```


```{r wave-amplitude-700, fig.cap = "Planteray wave amplitude for the regression patterns at 700 hPa.", fig.width=6, fig.height=4}
indexes_2d %>% 
  .[ lev == 700 & lat < -20] %>%
  .[, FitWave(estimate, 0:3), by = .(lat, lev, season, term)] %>% 
  ggplot(aes(lat, amplitude)) +
  geom_line(aes(color = factor(k))) +
  scale_color_brewer("Wave-number", palette = "Set1") +
  scale_y_continuous("Amplitude") +
  scale_x_latitude(ticks = 15) +
  coord_flip() +
  facet_grid(term~season, labeller = labeller(term = lab_sam), scales = "free_x")
```


```{r 2d-regr-30, fig.cap = "Seasonal regression patterns of geopotential height at 30 hPa with the Full, Asymmetric and Symmetric SAM. The regression patterns for Asymmetric and Symmetric SAM are the result of one multiple regression using both indices, not of two simple regressions involving each index by itsef.", fig.width =10, fig.height=7, fig.env = "sidewaysfigure"}
indexes_2d %>% 
  .[lat <= -20] %>% 
  .[lev == 30] %>% 
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = estimate),  breaks = AnchorBreaks(0, binwidth = 20, 0),
                    global.breaks = FALSE) +
  geom_contour_tanaka(aes(z = estimate),
                      breaks = AnchorBreaks(0, binwidth = 20, 0),
                      size = 0.3,
                      global.breaks = FALSE) +
  geom_qmap(~.x[lat <= -20]) +
  scale_x_longitude() +
  scale_y_latitude(limits = c(NA, -20), labels = NULL) +
  scale_fill_divergent(NULL, guide = guide_colorstrip_bottom(),
                       limits = c(-105, 105),
                       oob = scales::squish,
                       breaks = AnchorBreaks(0, binwidth = 20, 0)) +
  scale_linetype(guide = "none") +
  coord_polar() +
  facet_grid(term ~ season, labeller = labeller(term = lab_sam, lev = lev.lab)) +
  axis_labs_smol
```

```{r wave-amplitude-30, fig.cap = "Planteray wave amplitude for the regression patterns at 30 hPa.", fig.width=6, fig.height=4}
indexes_2d %>% 
  .[ lev == 30 & lat < -20] %>%
  .[, FitWave(estimate, 0:3), by = .(lat, lev, season, term)] %>% 
  ggplot(aes(lat, amplitude)) +
  geom_line(aes(color = factor(k))) +
  scale_color_brewer("Wave-number", palette = "Set1") +
  scale_y_continuous("Squared amplitude") +
  scale_x_latitude(ticks = 15) +
  coord_flip() +
  facet_grid(term~season, labeller = labeller(term = lab_sam), scales = "free_x") 
```

```{r compute-pp-regr} 
pp <- CMAP() %>% 
  ReadNetCDF(subset = list(lat = c(-90, -20))) %>% 
  normalise_coords() %>% 
  .[, precip := Anomaly(precip), by = .(lon, lat)]


pp_regr_season <- pp %>% 
  # .[, air := Anomaly(air), by = .(lon, lat)] %>%
  .[indexes_wide[lev == 700], on = .NATURAL] %>% 
  rm_singleton() %>% 
  .[, lapply(.SD, mean, na.rm = TRUE), by = .(lon, lat, time = seasonally(time))] %>%
  .[, nas := mean(is.na(precip)), by = .(lon, lat, season(time))] %>% 
  .[nas >= 0.15, precip := NA] %>% 
  .[, rbind(as.data.table(FitLm(precip, asym, sym, se = TRUE)),
            as.data.table(FitLm(precip, full, se = TRUE))),
    by = .(lon, lat, season(time))] %>% 
  rm_intercept() %>% 
  .[, p.value := Pvaluate(estimate, std.error, df, "fdr"), by = .(season, term)]

```

```{r pp-regr-global,  fig.cap = "Regression pattern of precipiation with Asymmetric and Symmetric SAM. P-values smaller than 0.05 (controlling for Flase Detection Rate) as hatched areas.", fig.width =10, fig.height=7, fig.env = "sidewaysfigure"}
pp_regr_season %>%
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = estimate), na.fill = 0, breaks = AnchorBreaks(0, 0.25, 0)) +
  geom_contour2(aes(z = p.value), breaks = 0.01) +
  geom_contour_fill(aes(z = as.numeric(is.na(estimate))), breaks = 1) +
  stat_subset(aes(subset = p.value <= 0.01 & is.cross(lon, lat)), size = 0.4, alpha = 0.3) +
  geom_qmap(~.x[lat <= -20]) +
  scale_x_longitude() +
  scale_y_latitude(labels = NULL) +
  scale_fill_divergent("Precipitation", guide = guide_colorstrip_bottom(), 
                       breaks = AnchorBreaks(0, 0.25, 0)) +
  coord_polar() +
  facet_grid(term ~ season, labeller = labeller(term = lab_sam, lev = lev.lab)) +
  axis_labs_smol
```


```{r regr-pp-season, fig.cap = "Regression pattern of precipiation with Asymmetric and Symmetric SAM. P-values smaller than 0.05 (controlling for Flase Detection Rate) as hatched areas.", invisible = TRUE}

is.sa <- function(data, lons = c(265, 325), lats = c(-80, -10)) {
  data[, lon %between% lons & lat %between% lats]
}

filter_sa <- function(data, lons = c(265, 325), lats = c(-80, -10)) {
  data[is.sa(data, lons = lons, lats = lats)]
}

pp_regr_season %>% 
  filter_sa() %>% 
  .[, lon := ConvertLongitude(lon)] %>% 
  ggplot(aes(lon, lat)) +
  # geom_raster(aes(fill = estimate)) +
  geom_contour_fill(aes(z = estimate), na.fill = 0, breaks = AnchorBreaks(0, 0.25, 0)) +
  geom_contour2(aes(z = p.value), breaks = 0.01) +
  geom_contour_fill(aes(z = as.numeric(is.na(estimate))), breaks = 1) +
  stat_subset(aes(subset = p.value <= 0.01 & is.cross(lon, lat)), size = 0.4, alpha = 0.3) +
  geom_qmap(~filter_sa(.x)[, lon := ConvertLongitude(lon)], keep = 0.02) +
  scale_x_longitude() +
  scale_y_latitude() +
  scale_fill_divergent("Precipitation", guide = guide_colorstrip_bottom(), 
                       breaks = AnchorBreaks(0, 0.25, 0)) +
  # coord_polar() +
  ggalt::coord_proj("+proj=moll +lon_0=-60") +
  facet_grid(season~term, labeller = labeller(term = lab_sam)) +
  axis_labs_smol
```


```{r compute-air-regr}
time_subset <- list(time = range(indexes$time))
air <- NOAATemp() %>% 
  ReadNetCDF(vars = "air", subset = c(time_subset, list(lat = c(-90, 10)))) %>% 
  normalise_coords() 

air_regr <- air %>% 
  # .[, air := Anomaly(air), by = .(lon, lat)] %>%
  .[indexes_wide[lev == 700], on = .NATURAL] %>% 
  rm_singleton() %>% 
  .[, lapply(.SD, mean, na.rm = TRUE), by = .(lon, lat, time = seasonally(time))] %>%
  .[, nas := mean(is.na(air)), by = .(lon, lat, season(time))] %>% 
  .[nas >= 0.15, air := NA] %>% 
  .[, rbind(as.data.table(FitLm(air, asym, sym, se = TRUE)),
            as.data.table(FitLm(air, full, se = TRUE))),
    by = .(lon, lat, season(time))] %>% 
  rm_intercept() 
```


```{r regr-air-season, fig.cap = "Regression pattern of surface temperature with Asymmetric and Symmetric SAM. P-values smaller than 0.05 (controlling for Flase Detection Rate) as hatched areas.", fig.width = 10, fig.height = 7, fig.env = "sidewaysfigure"}
air_regr %>% 
  copy() %>% 
  .[lat <= -61, estimate := NA] %>%
  .[lat >= 65, estimate := NA] %>%
  .[, p.value := Pvaluate(estimate, std.error, df, "fdr"), by = .(term, season)] %>% 
  ggplot(aes(lon, lat)) +
  geom_contour_fill(aes(z = estimate), na.fill = 0,
                    breaks = AnchorBreaks(0, 0.15, 0)) +
  # geom_raster(aes(fill = estimate)) +
  geom_contour2(aes(z = p.value), breaks = 0.05) +
  stat_subset(aes(subset = p.value <= 0.05 & is.cross(lon, lat)), size = 0.4, alpha = 0.8) +
  # stat_subset(aes(subset = is.na(estimate)), geom = "raster", fill = "gray50") +
  geom_qmap(~.x[lat <= 10]) +
  scale_x_longitude() +
  scale_y_latitude(labels = NULL) +
  scale_fill_divergent("Surface temperature",  limits = c(-0.8, .8), oob = scales::squish,
                       guide = guide_colorstrip_bottom(), breaks = AnchorBreaks(0, 0.15, 0)) +
  coord_polar() +
  facet_grid(term ~ season, labeller = labeller(term = lab_sam, lev = lev.lab)) +
  axis_labs_smol
```


\acknowledgments
CMAP Precipitation data provided by the NOAA/OAR/ESRL PSL, Boulder, Colorado, USA, from their Web site at https://psl.noaa.gov/

NOAA Global Surface Temperature (NOAAGlobalTemp) data provided by the NOAA/OAR/ESRL PSL, Boulder, Colorado, USA, from their Web site at https://psl.noaa.gov/ 


\bibliography{AsymSAM}

\appendix

\appendixtitle{Extra figures}



```{r A1, fig.cap = "Lag-correlation between Symmetric and Asymmetric SAM at each level.", fig.width = 4, fig.height=4, appendix = TRUE}
ccf_dt <- function(..., plot = FALSE) {
  stat <- ccf(..., plot = plot)
  list(lag = stat$lag[, 1, 1], 
       acf = stat$acf[, 1, 1])
}

indexes_wide %>% 
  .[, ccf_dt(asym, sym, lag.max = 5), by = .(lev)] %>% 
  ggplot(aes(lag, lev)) +
  geom_contour_fill(aes(z = acf), breaks = AnchorBreaks(0, 0.05)) +
  geom_vline(xintercept = 0) +
  scale_fill_divergent(NULL, guide = guide_colorstrip_bottom(), breaks = AnchorBreaks(0, 0.05)) +
  scale_x_continuous("\u2190 Asym leads Sym\t \t\t Sym leads Asym \U2192", breaks = seq(-5, 5, 1), 
                     expand = c(0, 0)) +
  scale_y_level()
```


```{r}
my_spectrum <- function(data, spans = NULL, R = 1000, ..., probs = 0.95) {
  mtm <- spec.pgram(data, spans = spans, ..., plot = FALSE)
  
  out <- as.data.table(mtm[c("freq", "spec")])
  
  out[, boot_null := null_spec(data, spans = spans, R = R, ..., probs = probs)]
  
  return(out[])
}


null_spec <- memoise::memoise(function(data, spans, R = 1000, ..., probs = 0.95) {
  
  b <- boot::boot(data, function(d, i) spec.pgram(d[i], spans = spans, 
                                                  ...,
                                                  plot = FALSE)$spec, 
                  R = R)
  
  apply(b$t, 2, quantile, probs = probs)
})

indexes %>% 
  copy() %>% 
  # .[, estimate_norm := estimate_norm/sd(estimate_norm), by = .(lev, term)] %>% 
  .[, my_spectrum(estimate_norm, 5), by = .(term, lev)] -> spec
```

```{r A2, fig.cap = "Foutier spectrum", appendix = TRUE}
spec %>%
  .[lev %in% c(30, 700)] %>% 
  ggplot(aes(1/freq/12, spec)) +
  # geom_ribbon(aes(group = interaction(term, rleid(sign(spec - boot_null))), 
  #                 fill = sign(spec - boot_null),
  #                 ymin = spec, ymax = boot_null)) +
    geom_line(aes(color = term)) +
  geom_line(aes(color = term, y = boot_null)) +
  annotation_logticks(sides = "b") +
  scale_color_brewer(palette = "Set1") +
  scale_fill_divergent() +
  scale_x_log10() +
  facet_grid(lev ~ .,labeller = labeller(lev = lev.lab))
```


```{r A3, fig.cap = "Trends for each index at each level. Shading indicates the 95\\% confidence interval.", fig.width = 3, fig.height=3.5, appendix = TRUE}
indexes %>%
  copy() %>% 
  .[, estimate_norm := estimate_norm/sd(estimate_norm), by = .(lev, term)] %>%
  .[, FitLm(estimate_norm, time, se = TRUE), by = .(lev, type = term)] %>% 
  rm_intercept() %>% 
  .[, term := NULL] %>% 
  .[, estimate := estimate*3600*24*365*10] %>% 
  .[, std.error := std.error*3600*24*365*10] %>% 
  setnames("type", "term") %>% 
  ggplot(aes(lev, estimate)) +
  geom_ribbon(aes(ymax = estimate + std.error*1.96, ymin = estimate - std.error*1.96, fill = term), alpha = 0.3) +
  geom_line(aes(color = term)) + 
  geom_hline(yintercept = 0) +
  scale_x_level() +
  coord_flip() 
```
